<!DOCTYPE html>
<html lang="en">
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    <title>FOAM Developer portal |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/foam.developer/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/foam.developer/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"foamlite/approach.html","title":""},"data":{"navigation":{"logo":{"text":"FOAM Developer portal","type":"link","path":"index.html"},"main":[{"text":"Introduction","type":"link","null":null,"path":"index.html"},{"text":"API Examples","type":"link","path":"examples/foam_map_api.html","children":[{"text":"Plot points","type":"link","path":"examples/example_1.html"},{"text":"Display tool tips","type":"link","path":"examples/example_2.html"},{"text":"Change the theme","type":"link","path":"examples/example_3.html"},{"text":"Density of points","type":"link","path":"examples/example_6.html"},{"text":"Map local restaurants","type":"link","path":"examples/example_7.html"},{"text":"Map a path","type":"link","path":"examples/example_8.html"},{"text":"Custom icons","type":"link","path":"examples/example_4.html"},{"text":"3D buildings","type":"link","path":"examples/example_5.html"}]},{"text":"Resources","type":"label","children":[{"text":"Videos","type":"link","path":"resources/videos.html"},{"text":"Repos","type":"link","path":"https://github.com/f-o-a-m/"}]},{"text":"FOAM Lite","type":"label","children":[{"text":"Introduction","type":"link","path":"foamlite/introduction.html"},{"text":"Approach","type":"link","path":"foamlite/approach.html"},{"text":"Real World Example","type":"link","path":"foamlite/nft.html"},{"text":"GitHub Repo","type":"link","path":"foamlite/repo.html"},{"text":"End Node","type":"link","path":"foamlite/end-node.html"}]},{"text":"Support & Feedback","type":"label"},{"text":"Raise an Issue on Github","type":"link","path":"https://github.com/f-o-a-m/foam.developer/issues/new"}]}},"config":{"timezone":"UTC","root":"/foam.developer/","time_format":"HH:mm:ss","theme":"../node_modules/foam-hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"/images/favicon.ico","google_analytics":"UA-111781922-3"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/foam.developer/index.html" class="doc-navbar__logo"><img src="/foam.developer/images/logo.png" class="doc-navbar__logo__img"><span class="doc-navbar__logo__text">FOAM Developer portal</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <h1 id="The-FOAM-Lite-Approach"><a href="#The-FOAM-Lite-Approach" class="headerlink" title="The FOAM Lite Approach"></a>The FOAM Lite Approach</h1><p>With the constraints outlined in the introduction, we can now start looking at what an LPWAN-based Ethereum interaction would look like. We’ll start by examining the network topology necessary for a decentralized application receiving data from on-the-ground end devices, followed by a practical example of how such an interaction takes place. We will assume a that we are operating with a basic Layer 1 Ethereum model using familiar ERC20 and ERC721 token transactions, though there is nothing precluding the approach from being modified to take advantage of Layer 2 scaling solutions.</p>
<h2 id="LPWAN-Network-Architecture"><a href="#LPWAN-Network-Architecture" class="headerlink" title="LPWAN Network Architecture"></a>LPWAN Network Architecture</h2><p>By now, we’ve seen how a network topology without a centralized network server is important for blockchain applications. Fortunately for us, the concentrators are devices which are capable of communicating over the broader internet and therefore connect to an Ethereum node. Many off-the-shelf LoRa gateway solutions are based on hardware platforms capable of running an Ethereum node themselves. This means that we can start simplifying the overall network architecture — the gateways serve act as <strong><em>Relayers</em></strong> to the blockchain, and the end nodes are <strong><em>Relayees</em></strong>, having their messages relayed by the gateway. Relayers can operate as regular LPWAN gateways, but they can also test if an LPWAN packet they have received actually encodes a smart contract interaction. If it’s meaningful to do so, the relayer can submit the smart contract interaction as a blockchain transaction on the relayee’s behalf. Effectively, we have a system in which an LPWAN end node can ultimately trigger behavior on a blockchain.</p>
<p><img src="images/foamlite-network-architecture.png" alt="FOAM Lite Network Architecture"></p>
<p>FOAM Lite Network Architecture</p>
<h2 id="Design-Considerations"><a href="#Design-Considerations" class="headerlink" title="Design Considerations"></a>Design Considerations</h2><p>Now that we have a high-level path towards a relayee-to-blockchain interaction, we can take stock of what challenges and opportunities are presented to us. We find that we have some critical motivations to consider that will ultimately inform the design of the messages the relayee can send, as well as certain functional requirements of the smart contracts that they will interact with.</p>
<ol>
<li>Relayer Incentivization: Running a relayer requires effort and has tangible costs — relayer hardware, internet backhaul, Ethereum infrastructure all need to be accounted for. Moreover, submitting transactions to Ethereum has gas costs in Ether, which must be paid for by the relayer as they will ultimately be one submitting the transaction to the chain. Much as most blockchains have the notion of transaction fees to incentivize actors to validate and secure the chain, we can similarly require that a message somehow causes a transaction fee to be delivered to the relayer for their services.</li>
<li>Authentication: Without an authenticated transaction, how can the relayer be certain they’ll get paid for their services? Who is paying them? With what? Most blockchains are predicated on cryptographic identities, with signatures used for authenticating transactions. We can apply that same primitive to the end node’s message and require that it be signed by the end node’s unique private key. This would enable a means for the relayer to verify that the transaction fee for a given message can actually be recouped.</li>
<li>Replay Protection: Because these transactions are being broadcast over the air where theoretically anybody can receive them, we would like to ensure that whatever transaction a relayee wishes to submit can only be executed exactly once. At the very least, we would like to stop a greedy relayer from resubmitting the same message to the chain and collect the transaction fee repeatedly while the end node can keep affording it. This is easily accomplished by including a number-used-once (nonce) in the message.</li>
<li>Payload: We have to remember that LPWAN packets are extremely small — with a maximum payload of up to 255 bytes per packet in the case of LoRa. Regional restrictions on RF spectrum usage may limit the quantity of packets that can be sent in a given time span. An Ethereum transaction, especially an ABI-encoded smart contract transaction can very quickly grow beyond the size of several such packets, so we must be careful with how we encode the payload being sent to the chain. Remember, we have to at least fit a signature and nonce, which is already likely to take up a nontrivial proportion of packet capacity.</li>
<li>Relayer-Awareness: Because it is the relayer ultimately submitting the transaction to the blockchain, the smart contracts that are being interacted with will see that the originator of the transaction is actually the relayer. The smart contract functions would need to take the entire message into account to securely identify the originator as the end node. This design requirement actually ends up helping us — if the smart contract is aware of the fact that it’s receiving a relayed message, then it can also serve to ensure the relayer gets their transaction fee incentive delivered. A relayer can then simply dry-run the transaction and determine whether or not the transaction fee they received in the simulation makes it reasonable to actually submit the transaction compared to the simulated costs of running the transaction. A diverse network of relayers then also creates a competitive transaction fee market, just as in common blockchain design.</li>
</ol>
<h2 id="Transaction-Fee-Considerations-and-Future-Work"><a href="#Transaction-Fee-Considerations-and-Future-Work" class="headerlink" title="Transaction Fee Considerations and Future Work"></a>Transaction Fee Considerations and Future Work</h2><p>Because we have chosen to demonstrate this approach with Ethereum, there are some additional nuances specific to the Ethereum blockchain that we have to consider in our design. Particularly, the transaction fees in Ethereum are calculated in terms of <em>gas</em>, which can only be paid for using the blockchain’s native currency, Ether. Unfortunately, the Ethereum blockchain by itself has no facilities to securely delegate access to the Ether balance of a user’s wallet to another user or smart contract — which means that transaction fees cannot be covered directly with Ether.</p>
<p>On the other hand, ERC20 tokens <em>do</em> have the ability to delegate control over some or all of a user’s balance of that token to another address by means of the <code>approve()</code> function. A particularly famous ERC20 token is known as <em>Wrapped Ether</em> or WETH, and is designed to be 1-to-1 exchange with actual Ether. Depending on the design requirements of the system, other similar tokens can of course be used.</p>
<p>Because an end node cannot readily know which relayer will be relaying their transaction a-priori, it does not make sense to simply approve a specific relayer. Moreover, simply approving a relayer would just allow that relayer to claim the approved balance without doing anything else, so that’s not really a viable solution. However, because the end node will likely know what contracts they intend to be interacting with, they can approve that specific contract to spend their ERC20 balance, and the contract can then ensure that the transaction fee makes it to the relayer if the transaction succeeds. This also adds a layer of assurance to the relayer that they will get rewarded for performing their duties.</p>
<p>Because we are using an ERC20 token, the end node will need to have some balance of that token, and will need to have somehow approved the smart contract they’re interacting with to spend that token on their behalf in order to pay the relayer. This means a small amount of ETH would need to be held by the end node as well. This may pose some logistical challenges when considering mass deployments/fleets of end nodes. For the sake of illustrating the technique, we will demonstrate a set of FOAM Lite interactions using an ERC20 token transaction fee in the message. However, smart contracts can be designed such that other means of paying the transaction fee are used. For example, a particular application can keep an on-chain registry of end node addresses that comprise their fleet, and have their particular smart contracts pay out relayers for relaying messages from those nodes. This would radically simplify fleet deployment and management. The end node would not need to periodically have its individual transaction fee balance replenished and the smart contract somehow reapproved to spend the new balance. This would also mean that the transaction fee can be elided from the end node’s message, enabling a larger payload, as well as allowing the overall application to be more responsive to gas market conditions.</p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    
<script>
  if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-111781922-3', 'auto');
    ga('send', 'pageview');
  }
</script>



    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/foam.developer/script/doc.js"></script>

    
      <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
      <script>
        if (window.mermaid) {
          mermaid.initialize({theme: 'forest'});
        }
      </script>
    

    

  </body>
</html>
